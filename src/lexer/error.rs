
use crate::lexer::{constants::Pos, token::token::TokenKind};
use std::fmt::{Display, Formatter, Error as FormatError};
use std::collections::VecDeque;

/// An Error generated by the Lexer
#[derive(Debug, Clone)]
pub(crate) struct Error<T> {
    pub(crate) kind: ErrorKind,
    pub(crate) trace: Traceback<T>
}

impl<A> Display for Error<A> {
    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result<(), FormatError> {
        fmt.write_str("Error: ")?;
        Display::fmt(&self.kind, fmt)?;
        // fmt.write_str("\n");
        Ok(())
    }
}

impl<B: std::fmt::Debug> std::error::Error for Error<B> {}

#[derive(Debug, Clone)]
pub(crate) enum ErrorKind {
    /// Invalid sequence while parsing Eg. an integer.
    InvalidSequence { kind: TokenKind, seq: String, pos: Pos /* [line, colum, char] */ },
    /// An invalid character wich doesn't match to any token.
    InvalidChar { chr: char, pos: Pos /* [line, colum, char] */ },
}

impl Display for ErrorKind {
    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result<(), FormatError> {

        match self {
            Self::InvalidSequence { kind, seq, pos } => {
                fmt.write_str(&format!("Invalid sequence \"{}\" for token of kind {} at {}:{}", seq, kind, pos[0], pos[1]))?;
            },
            Self::InvalidChar { chr, pos } => {
                fmt.write_str(&format!("Invalid character '{}' at {}:{}", chr, pos[0], pos[1]))?;
            }
        };
        Ok(())

    }
}

/// A collection of multiple T's wich checks for a max length.
#[derive(Debug, Clone, Default)]
pub(crate) struct Traceback<C> {
    limit: usize,
    steps: VecDeque<C>
}

impl <D>Traceback<D> {

    /// Add a L to the traceback and check for the max length.
    pub(crate) fn push(&mut self, step: D) {
        if self.steps.len() > self.limit { self.steps.pop_front().unwrap(); }
        self.steps.push_back(step);
    }

    /// Set the maximum number of steps to store.
    pub(crate) fn limit(&mut self, limit: usize) {
        if limit <= 0 { panic!("Limit may not be zero.") }
        self.limit = limit
    }

}

/// A "collection" of things a Lexer did inside a single call
/// to Lexer::next.
#[derive(Debug, Clone, Default)]
pub(crate) struct Log {
    
}
